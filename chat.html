<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Voice Chatbot - Enhanced</title>
    <style>
        :root {
            --primary-color: #2196F3;
            --secondary-color: #4CAF50;
            --error-color: #f44336;
            --warning-color: #ff9800;
            --background-color: #0a0a0a;
            --chat-bg: #1a1a1a;
            --user-msg-bg: #1e3a5f;
            --assistant-msg-bg: #1e3f2d;
            --border-radius: 16px;
            --shadow: 0 8px 32px rgba(0,0,0,0.3);
            --glass-bg: rgba(255,255,255,0.05);
            --glass-border: rgba(255,255,255,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--glass-border);
            padding: 20px;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: relative;
        }

        .header {
            background: rgba(26, 26, 26, 0.9);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            position: relative;
            z-index: 10;
        }

        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: transparent;
            position: relative;
        }

        .voice-visualization {
            position: fixed;
            top: 0;
            left: 320px;
            right: 0;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0.1;
        }

        .voice-visualization canvas {
            width: 100%;
            height: 100%;
        }

        .input-area {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-top: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            position: relative;
            z-index: 10;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .config-section {
            margin-bottom: 25px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius);
            padding: 15px;
            backdrop-filter: blur(10px);
        }

        .config-section h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: #ffffff;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #cccccc;
            font-size: 14px;
        }

        input[type="text"], select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            font-size: 14px;
            background: var(--glass-bg);
            color: #ffffff;
            backdrop-filter: blur(10px);
        }

        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.02);
            transition: background 0.2s;
        }

        .checkbox-group:hover {
            background: rgba(255,255,255,0.05);
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            accent-color: var(--primary-color);
        }

        .btn {
            background: linear-gradient(135deg, var(--primary-color), #1976D2);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .btn.secondary {
            background: linear-gradient(135deg, var(--secondary-color), #388E3C);
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
        }

        .btn.danger {
            background: linear-gradient(135deg, var(--error-color), #d32f2f);
            box-shadow: 0 4px 16px rgba(244, 67, 54, 0.3);
        }

        .message {
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow);
            position: relative;
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }

        .message.user {
            background: linear-gradient(135deg, var(--user-msg-bg), #2a5490);
            margin-left: 20px;
            border-left: 4px solid var(--primary-color);
        }

        .message.assistant {
            background: linear-gradient(135deg, var(--assistant-msg-bg), #2d5a3d);
            margin-right: 20px;
            border-left: 4px solid var(--secondary-color);
        }

        .message-content {
            line-height: 1.6;
            color: #ffffff;
        }

        /* Markdown styling for assistant messages */
        .message-content h1, .message-content h2, .message-content h3 {
            color: #ffffff;
            margin: 16px 0 12px 0;
            font-weight: bold;
        }

        .message-content h1 {
            font-size: 1.8em;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 8px;
        }

        .message-content h2 {
            font-size: 1.5em;
            color: #81c784;
        }

        .message-content h3 {
            font-size: 1.3em;
            color: #a5d6a7;
        }

        .message-content p {
            margin: 12px 0;
            line-height: 1.6;
        }

        .message-content ul, .message-content ol {
            margin: 12px 0;
            padding-left: 24px;
        }

        .message-content li {
            margin: 6px 0;
            line-height: 1.5;
        }

        .message-content blockquote {
            border-left: 4px solid var(--secondary-color);
            margin: 16px 0;
            padding: 12px 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            font-style: italic;
        }

        .message-content code {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #90caf9;
        }

        .message-content pre {
            background: rgba(0,0,0,0.4);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 12px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .message-content pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }

        .message-content strong {
            color: #ffffff;
            font-weight: bold;
        }

        .message-content em {
            color: #e8eaf6;
            font-style: italic;
        }

        .message-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .message-content a:hover {
            text-decoration: underline;
        }

        .message-content img {
            max-width: 300px;
            height: 200px;
            object-fit: cover;
            border-radius: 8px;
            margin: 5px;
        }

        .timestamp {
            font-size: 11px;
            color: #aaaaaa;
            margin-top: 8px;
        }

        .typing-indicator {
            background: linear-gradient(135deg, var(--assistant-msg-bg), #2d5a3d);
            border-left: 4px solid var(--secondary-color);
            padding: 15px 20px;
            margin: 20px 20px 20px 0;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--secondary-color);
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-10px); opacity: 1; }
        }

        .input-container {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            position: relative;
        }

        .voice-input-area {
            flex: 1;
            position: relative;
        }

        .message-input {
            width: 100%;
            min-height: 60px;
            max-height: 120px;
            padding: 15px 20px;
            border: 2px solid var(--glass-border);
            border-radius: var(--border-radius);
            resize: vertical;
            font-family: inherit;
            font-size: 16px;
            background: var(--glass-bg);
            color: #ffffff;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .message-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.2);
        }

        .message-input.voice-active {
            border-color: var(--error-color);
            box-shadow: 0 0 0 4px rgba(244, 67, 54, 0.3);
        }

        .voice-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .voice-btn {
            padding: 16px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            width: 64px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .mic-btn {
            background: linear-gradient(135deg, var(--error-color), #d32f2f);
            color: white;
            box-shadow: 0 4px 16px rgba(244, 67, 54, 0.4);
        }

        .mic-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.5);
        }

        .mic-btn.recording {
            background: linear-gradient(135deg, #ff5722, #bf360c);
            animation: pulse 2s infinite;
        }

        .mic-btn.recording::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(255, 87, 34, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: ripple 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes ripple {
            0% { width: 64px; height: 64px; opacity: 1; }
            100% { width: 100px; height: 100px; opacity: 0; }
        }

        .voice-status {
            font-size: 12px;
            color: #aaaaaa;
            text-align: center;
            min-height: 16px;
            transition: all 0.3s;
        }

        .voice-status.active {
            color: var(--error-color);
            font-weight: bold;
        }

        .send-btn {
            background: linear-gradient(135deg, var(--primary-color), #1976D2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 16px rgba(33, 150, 243, 0.4);
            min-width: 100px;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5);
        }

        .send-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .stop-btn {
            background: linear-gradient(135deg, var(--error-color), #d32f2f);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 16px rgba(244, 67, 54, 0.4);
            min-width: 100px;
            display: none;
        }

        .stop-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.5);
        }

        .stop-btn.active {
            display: block;
        }

        .audio-wave {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 60px;
            background: rgba(0,0,0,0.3);
            border-radius: 30px;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }

        .audio-wave.active {
            display: flex;
        }

        .wave-bars {
            display: flex;
            gap: 2px;
            align-items: center;
        }

        .wave-bar {
            width: 3px;
            height: 10px;
            background: var(--primary-color);
            border-radius: 2px;
            animation: wave 1s infinite ease-in-out;
        }

        .wave-bar:nth-child(odd) { animation-delay: 0.1s; }
        .wave-bar:nth-child(even) { animation-delay: 0.2s; }

        @keyframes wave {
            0%, 100% { height: 10px; opacity: 0.4; }
            50% { height: 25px; opacity: 1; }
        }

        .health-status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 13px;
            border: 1px solid;
        }

        .health-status.healthy {
            background: rgba(76, 175, 80, 0.1);
            border-color: var(--secondary-color);
            color: #81c784;
        }

        .health-status.unhealthy {
            background: rgba(244, 67, 54, 0.1);
            border-color: var(--error-color);
            color: #e57373;
        }

        .example-queries {
            max-height: 300px;
            overflow-y: auto;
        }

        .example-query {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
            color: #ffffff;
        }

        .example-query:hover {
            background: rgba(255, 152, 0, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.2);
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: blink 2s infinite;
        }

        .status-online { background: var(--secondary-color); }
        .status-offline { background: var(--error-color); }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 40vh;
            }
            
            .main-content {
                height: 60vh;
            }

            .voice-visualization {
                left: 0;
            }
        }

        .tts-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--secondary-color), #388E3C);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.4);
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tts-indicator.active {
            transform: translateY(0);
            opacity: 1;
        }

        .tts-indicator::before {
            content: 'üîä';
        }

        .tts-progress {
            width: 100px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .tts-progress-bar {
            width: 0%;
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .speech-indicator {
            position: absolute;
            top: -40px;
            right: 10px;
            background: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s;
            z-index: 20;
        }

        .speech-indicator.active {
            opacity: 1;
            transform: translateY(0);
        }

        .volume-meter {
            width: 60px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .volume-level {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #f44336);
            width: 0%;
            transition: width 0.1s;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="logo">ü§ñ AI Voice Chatbot</div>
        <p style="font-size: 13px; color: #aaa; margin-bottom: 20px;">
            Advanced voice-enabled AI with synchronized audio playback
        </p>

        <div class="config-section">
            <h3>‚öôÔ∏è Voice Settings</h3>
            <div class="form-group">
                <label>Session ID</label>
                <input type="text" id="sessionId" value="voice-session" placeholder="Enter session ID">
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="streamingMode" checked>
                <label for="streamingMode">üåä Streaming Mode</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="enhancedStreaming" checked>
                <label for="enhancedStreaming">üöÄ Enhanced Streaming</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="voiceMode" checked>
                <label for="voiceMode">üó£Ô∏è Voice Mode</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="autoTTS" checked>
                <label for="autoTTS">üîä Auto TTS for Voice Input</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="syncTTS">
                <label for="syncTTS">‚ö° Synchronized TTS</label>
            </div>

            <div class="form-group">
                <label>Speech Detection Sensitivity</label>
                <select id="speechSensitivity">
                    <option value="high">High (Quick)</option>
                    <option value="medium" selected>Medium</option>
                    <option value="low">Low (Patient)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Auto-Stop Delay (ms)</label>
                <select id="autoStopDelay">
                    <option value="800">0.8 seconds</option>
                    <option value="1200" selected>1.2 seconds</option>
                    <option value="1500">1.5 seconds</option>
                    <option value="2000">2 seconds</option>
                </select>
            </div>
        </div>

        <div class="config-section">
            <h3>üîß Backend Status</h3>
            <div id="healthStatus" class="health-status">
                <span class="status-indicator status-offline"></span>
                Checking connection...
            </div>
            <button class="btn" onclick="checkHealth()">ü©∫ Check Health</button>
        </div>

        <div class="config-section">
            <h3>üéØ Voice Examples</h3>
            <div class="example-queries">
                <div class="example-query" onclick="selectExample(this)">What's today's date?</div>
                <div class="example-query" onclick="selectExample(this)">How is the Nifty 50 performing?</div>
                <div class="example-query" onclick="selectExample(this)">Show me pictures of lions</div>
                <div class="example-query" onclick="selectExample(this)">Latest news from India</div>
                <div class="example-query" onclick="selectExample(this)">Tell me about Ranbir Kapoor</div>
                <div class="example-query" onclick="selectExample(this)">What's the Tesla stock price?</div>
            </div>
        </div>

        <div class="config-section">
            <button class="btn danger" onclick="clearChat()">üóëÔ∏è Clear Chat</button>
            <button class="btn secondary" onclick="newSession()">üîÑ New Session</button>
        </div>
    </div>

    <div class="main-content">
        <div class="voice-visualization">
            <canvas id="voiceVisualization"></canvas>
        </div>

        <div class="header">
            <h1>ü§ñ Voice-Enabled AI Chatbot</h1>
            <p style="font-size: 14px; color: #aaa; margin-top: 5px;">
                üöÄ GPT-4 ‚Ä¢ üîç Web Search ‚Ä¢ üñºÔ∏è Images ‚Ä¢ üì∞ News ‚Ä¢ üé§ Voice Chat ‚Ä¢ ‚ö° Sync Audio
            </p>
        </div>

        <div class="chat-container" id="chatContainer">
            <!-- Messages will be added here dynamically -->
        </div>

        <div class="tts-indicator" id="ttsIndicator">
            AI is speaking...
            <div class="tts-progress">
                <div class="tts-progress-bar" id="ttsProgressBar"></div>
            </div>
            <div id="speaking-indicator">üéôÔ∏è Server detecting speech...</div>
        </div>

        <div class="audio-wave" id="audioWave">
            <div class="wave-bars">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
        </div>

        <div class="input-area">
            <div class="input-container">
                <div class="voice-input-area">
                    <div class="speech-indicator" id="speechIndicator">
                        üéôÔ∏è Speaking detected
                        <div class="volume-meter">
                            <div class="volume-level" id="volumeLevel"></div>
                        </div>
                    </div>
                    <textarea 
                        id="messageInput" 
                        class="message-input" 
                        placeholder="Speak or type your message..."
                        rows="2"
                    ></textarea>
                </div>
                
                <div class="voice-controls" id="voiceControls">
                    <button class="voice-btn mic-btn" id="micBtn" onclick="toggleRecording()">üé§</button>
                    <div class="voice-status" id="voiceStatus">Ready</div>
                </div>
                
                <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
                <button class="stop-btn" id="stopBtn" onclick="stopGeneration()">Stop</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script>
        // Configuration
        const BACKEND_BASE_URL = window.location.origin;
        
        // Global state
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let messages = [];
        let isStreaming = false;
        let currentTTSAudio = null;
        let voiceVisualization = null;
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let speechTimer = null;
        let silenceTimer = null;
        let wasVoiceInput = false;
        let streamController = null;
        let ttsController = null;
        let speechDetectionActive = false;
        let speechStartTime = null;
        let lastSpeechTime = null;
        let currentStream = null;
        let ttsQueue = [];
        let isProcessingTTS = false;
        let speechVolumes = []; // Track volume history for better detection
        let speechState = 'waiting'; // 'waiting', 'speaking', 'silence'

        // Fixed speech detection thresholds with better values
        const speechThresholds = {
            high: { 
                silence: 800,        
                minSpeech: 500,      
                volumeThreshold: 25, // Adjusted for better noise rejection
                confidenceFrames: 3,
                silenceFrames: 8
            },
            medium: { 
                silence: 1200, 
                minSpeech: 700, 
                volumeThreshold: 20,
                confidenceFrames: 5,
                silenceFrames: 12
            },
            low: { 
                silence: 1800, 
                minSpeech: 1000, 
                volumeThreshold: 15,
                confidenceFrames: 8,
                silenceFrames: 18
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            checkHealth();
            setupEventListeners();
            toggleVoiceControls();
            initVoiceVisualization();
            setupMarked();
        });

        function setupMarked() {
            // Configure marked for better rendering
            marked.setOptions({
                gfm: true,
                breaks: true,
                headerIds: false,
                mangle: false
            });
        }

        function initVoiceVisualization() {
            const canvas = document.getElementById('voiceVisualization');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            voiceVisualization = { canvas, ctx };
        }

        function setupEventListeners() {
            document.getElementById('messageInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            document.getElementById('voiceMode').addEventListener('change', toggleVoiceControls);

            // Auto-resize textarea
            document.getElementById('messageInput').addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
            });

            // Detect manual typing (not voice input)
            document.getElementById('messageInput').addEventListener('input', function() {
                if (!isRecording) {
                    wasVoiceInput = false;
                }
            });
        }

        function toggleVoiceControls() {
            const voiceMode = document.getElementById('voiceMode').checked;
            const voiceControls = document.getElementById('voiceControls');
            voiceControls.style.display = voiceMode ? 'flex' : 'none';
        }

        async function checkHealth() {
            const healthStatus = document.getElementById('healthStatus');
            try {
                const response = await fetch(`${BACKEND_BASE_URL}/health`);
                if (response.ok) {
                    const data = await response.json();
                    healthStatus.innerHTML = '<span class="status-indicator status-online"></span>‚úÖ Backend is healthy!';
                    healthStatus.className = 'health-status healthy';
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                healthStatus.innerHTML = '<span class="status-indicator status-offline"></span>‚ùå Cannot connect to backend';
                healthStatus.className = 'health-status unhealthy';
            }
        }

        function selectExample(element) {
            document.getElementById('messageInput').value = element.textContent;
            wasVoiceInput = false;
            sendMessage();
        }

        function clearChat() {
            messages = [];
            document.getElementById('chatContainer').innerHTML = '';
            stopAllAudio();
        }

        function newSession() {
            clearChat();
            document.getElementById('sessionId').value = `voice_${Date.now()}`;
        }

        function stopAllAudio() {
            // Stop current TTS
            if (currentTTSAudio) {
                currentTTSAudio.pause();
                currentTTSAudio.currentTime = 0;
                currentTTSAudio = null;
            }
            
            // Cancel TTS controller
            if (ttsController) {
                ttsController.abort();
                ttsController = null;
            }
            
            // Clear TTS queue - FIXED: Prevent multiple audio playback
            ttsQueue.length = 0;
            isProcessingTTS = false;
            
            hideTTSIndicator();
        }

        function stopGeneration() {
            // Stop streaming
            if (streamController) {
                streamController.abort();
                streamController = null;
            }
            
            // Stop current stream
            if (currentStream) {
                try {
                    currentStream.cancel();
                } catch (e) {
                    console.log('Stream already closed');
                }
                currentStream = null;
            }
            
            // Stop all audio
            stopAllAudio();
            
            // Reset UI
            isStreaming = false;
            document.getElementById('sendBtn').disabled = false;
            document.getElementById('stopBtn').classList.remove('active');
            hideTypingIndicator();
            
            console.log('Generation stopped by user');
        }

        function renderMarkdown(content) {
            // Process markdown and handle images
            let processedContent = content;
            
            // First handle image markdown
            processedContent = processedContent.replace(
                /!\[([^\]]*)\]\(([^)]+)\)/g,
                '<img src="$2" alt="$1" style="max-width: 300px; height: 200px; object-fit: cover; border-radius: 8px; margin: 5px;" />'
            );
            
            // Then process other markdown
            try {
                processedContent = marked.parse(processedContent);
            } catch (error) {
                console.warn('Markdown parsing error:', error);
                // Fallback to simple processing
                processedContent = processedContent
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>')
                    .replace(/\n/g, '<br>');
            }
            
            return processedContent;
        }

        function addMessage(role, content, timestamp = null) {
            const message = {
                role,
                content,
                timestamp: timestamp || new Date().toLocaleTimeString()
            };
            messages.push(message);
            
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (role === 'assistant') {
                // FIXED: Proper markdown rendering
                contentDiv.innerHTML = renderMarkdown(content);
            } else {
                contentDiv.textContent = content;
            }
            
            const timestampDiv = document.createElement('div');
            timestampDiv.className = 'timestamp';
            timestampDiv.textContent = `üïí ${message.timestamp}`;
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timestampDiv);
            chatContainer.appendChild(messageDiv);
            
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function showTypingIndicator() {
            const chatContainer = document.getElementById('chatContainer');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
                <span style="margin-left: 15px; font-size: 13px; color: #aaa;">AI is thinking...</span>
            `;
            chatContainer.appendChild(typingDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }

        function showTTSIndicator(text = 'AI is speaking...') {
            const indicator = document.getElementById('ttsIndicator');
            indicator.querySelector('::before') ? null : indicator.insertAdjacentHTML('afterbegin', text);
            indicator.classList.add('active');
        }

        function hideTTSIndicator() {
            const indicator = document.getElementById('ttsIndicator');
            indicator.classList.remove('active');
            updateTTSProgress(0);
        }

        function updateTTSProgress(percent) {
            const progressBar = document.getElementById('ttsProgressBar');
            progressBar.style.width = `${Math.min(percent, 100)}%`;
        }

        // FIXED: Improved TTS management to prevent multiple audio playback
        async function generateTTS(text, textElement = null) {
            if (!text || !text.trim()) return;
            
            // Stop any existing audio before starting new one
            if (currentTTSAudio) {
                currentTTSAudio.pause();
                currentTTSAudio = null;
            }
            
            const cleanText = cleanTextForTTS(text);
            if (!cleanText || cleanText.length < 5) return; // Skip very short text
            
            try {
                showTTSIndicator('Generating speech...');
                
                // Create abort controller for this TTS request
                if (ttsController) {
                    ttsController.abort();
                }
                ttsController = new AbortController();
                
                const response = await fetch(`${BACKEND_BASE_URL}/tts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: cleanText }),
                    signal: ttsController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`TTS failed: ${response.status}`);
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                currentTTSAudio = new Audio(audioUrl);
                
                // Setup audio event listeners
                currentTTSAudio.onloadedmetadata = () => {
                    console.log(`TTS loaded: ${currentTTSAudio.duration.toFixed(2)}s for ${cleanText.length} chars`);
                };
                
                currentTTSAudio.ontimeupdate = () => {
                    if (currentTTSAudio.duration > 0) {
                        const progress = (currentTTSAudio.currentTime / currentTTSAudio.duration) * 100;
                        updateTTSProgress(progress);
                    }
                };
                
                currentTTSAudio.onended = () => {
                    console.log('TTS playback ended');
                    hideTTSIndicator();
                    URL.revokeObjectURL(audioUrl);
                    currentTTSAudio = null;
                    ttsController = null;
                    
                    // Process next item in queue
                    processNextTTS();
                };
                
                currentTTSAudio.onerror = (e) => {
                    console.error('TTS playback error:', e);
                    hideTTSIndicator();
                    URL.revokeObjectURL(audioUrl);
                    currentTTSAudio = null;
                    ttsController = null;
                    processNextTTS();
                };
                
                showTTSIndicator('AI is speaking...');
                await currentTTSAudio.play();
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('TTS generation aborted');
                } else {
                    console.error('TTS error:', error);
                }
                hideTTSIndicator();
                currentTTSAudio = null;
                ttsController = null;
                processNextTTS();
            }
        }

        function cleanTextForTTS(text) {
            return text
                .replace(/<[^>]+>/g, ' ') // Remove HTML tags
                .replace(/!\[.*?\]\(.*?\)/g, '') // Remove images
                .replace(/\[.*?\]\(.*?\)/g, '') // Remove links
                .replace(/https?:\/\/\S+/g, '') // Remove standalone URLs
                .replace(/#{1,6}\s/g, '') // Remove headers
                .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
                .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
                .replace(/`(.*?)`/g, '$1') // Remove code markdown
                .replace(/\s+/g, ' ') // Normalize whitespace
                .replace(/[^\w\s.,!?;:-]/g, '') // Remove special characters except punctuation
                .trim();
        }

        // FIXED: Simplified TTS queue to prevent duplicates
        function queueTTS(text, textElement = null) {
            if (isProcessingTTS) {
                return; // Skip if already processing to prevent duplicates
            }
            
            const cleanText = cleanTextForTTS(text);
            if (cleanText && cleanText.length > 10) {
                ttsQueue.push({ text: cleanText, textElement });
                if (!isProcessingTTS) {
                    processNextTTS();
                }
            }
        }

        async function processNextTTS() {
            if (ttsQueue.length === 0) {
                isProcessingTTS = false;
                return;
            }
            
            isProcessingTTS = true;
            const { text, textElement } = ttsQueue.shift();
            
            // Clear remaining queue to prevent buildup
            ttsQueue.length = 0;
            
            await generateTTS(text, textElement);
        }

        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const query = messageInput.value.trim();
            const sessionId = document.getElementById('sessionId').value.trim() || 'default';
            const streaming = document.getElementById('streamingMode').checked;
            const enhanced = document.getElementById('enhancedStreaming').checked;
            const voiceMode = document.getElementById('voiceMode').checked;
            const autoTTS = document.getElementById('autoTTS').checked;
            
            if (!query) return;
            
            messageInput.value = '';
            messageInput.style.height = 'auto';
            messageInput.classList.remove('voice-active');
            
            // Stop any current operations
            stopAllAudio();
            
            addMessage('user', query);
            
            if (isStreaming) return;
            isStreaming = true;
            
            document.getElementById('sendBtn').style.display = 'none';
            document.getElementById('stopBtn').classList.add('active');
            
            try {
                if (streaming) {
                    await handleStreamingResponse(query, sessionId, enhanced, voiceMode && wasVoiceInput && autoTTS);
                } else {
                    await handleRegularResponse(query, sessionId, voiceMode && wasVoiceInput && autoTTS);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error sending message:', error);
                    addMessage('assistant', `‚õî Error: ${error.message}`);
                }
            } finally {
                isStreaming = false;
                document.getElementById('sendBtn').style.display = 'block';
                document.getElementById('stopBtn').classList.remove('active');
                hideTypingIndicator();
                wasVoiceInput = false;
                streamController = null;
            }
        }

        async function handleRegularResponse(query, sessionId, shouldUseTTS) {
            showTypingIndicator();
            
            streamController = new AbortController();
            
            const response = await fetch(`${BACKEND_BASE_URL}/chatbot`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    query: query,
                    session_id: sessionId
                }),
                signal: streamController.signal
            });
            
            hideTypingIndicator();
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            const assistantResponse = data.response;
            
            addMessage('assistant', assistantResponse);
            
            if (shouldUseTTS && assistantResponse.trim()) {
                const lastMessage = document.querySelector('.message.assistant:last-child .message-content');
                queueTTS(assistantResponse, lastMessage);
            }
        }

        async function handleStreamingResponse(query, sessionId, enhanced, shouldUseTTS) {
            const endpoint = enhanced ? '/chatbot/stream-v2' : '/chatbot/stream';
            const params = new URLSearchParams({
                query: query,
                session_id: sessionId
            });
            
            const url = `${BACKEND_BASE_URL}${endpoint}?${params}`;
            
            streamController = new AbortController();
            
            try {
                const response = await fetch(url, {
                    signal: streamController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const reader = response.body.getReader();
                currentStream = reader;
                const decoder = new TextDecoder();
                
                let assistantResponse = '';
                let messageDiv = null;
                let contentDiv = null;
                
                // Create streaming message container
                const chatContainer = document.getElementById('chatContainer');
                messageDiv = document.createElement('div');
                messageDiv.className = 'message assistant';
                
                contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'timestamp';
                timestampDiv.textContent = `üïí ${new Date().toLocaleTimeString()}`;
                
                messageDiv.appendChild(contentDiv);
                messageDiv.appendChild(timestampDiv);
                chatContainer.appendChild(messageDiv);
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonData = line.slice(6).trim();
                                if (jsonData && jsonData !== '[DONE]' && jsonData !== '[CANCELLED]' && jsonData !== '[ERROR]') {
                                    const data = JSON.parse(jsonData);
                                    if (typeof data === 'string') {
                                        assistantResponse += data;
                                        
                                        // FIXED: Update display with proper markdown rendering
                                        contentDiv.innerHTML = renderMarkdown(assistantResponse);
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                    }
                                }
                            } catch (e) {
                                // Ignore JSON parse errors in streaming
                            }
                        }
                    }
                }
                
                // Add to messages array
                if (assistantResponse.trim()) {
                    messages.push({
                        role: 'assistant',
                        content: assistantResponse,
                        timestamp: new Date().toLocaleTimeString()
                    });
                    
                    // FIXED: Generate TTS only once for complete response
                    if (shouldUseTTS) {
                        queueTTS(assistantResponse, contentDiv);
                    }
                }
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Streaming error:', error);
                    addMessage('assistant', `‚õî Streaming error: ${error.message}`);
                }
            } finally {
                currentStream = null;
            }
        }

        async function toggleRecording() {
            const micBtn = document.getElementById('micBtn');
            const messageInput = document.getElementById('messageInput');
            
            if (!isRecording) {
                await startRecording();
                micBtn.textContent = '‚èπÔ∏è';
                micBtn.classList.add('recording');
                messageInput.classList.add('voice-active');
                document.getElementById('voiceStatus').textContent = 'Listening...';
                document.getElementById('voiceStatus').classList.add('active');
                document.getElementById('audioWave').classList.add('active');
                isRecording = true;
            } else {
                await stopRecording();
                micBtn.textContent = 'üé§';
                micBtn.classList.remove('recording');
                messageInput.classList.remove('voice-active');
                document.getElementById('voiceStatus').textContent = 'Processing...';
                document.getElementById('audioWave').classList.remove('active');
                document.getElementById('speechIndicator').classList.remove('active');
                isRecording = false;
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    } 
                });
                
                // Setup audio visualization and speech detection
                setupAudioVisualization(stream);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm'
                });
                audioChunks = [];
                
                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    if (audioChunks.length > 0) {
                        const audioBlob = new Blob(audioChunks, { 
                            type: mediaRecorder.mimeType || 'audio/webm' 
                        });
                        await transcribeAudio(audioBlob);
                    }
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                    
                    // Clean up audio context
                    if (audioContext) {
                        audioContext.close();
                        audioContext = null;
                    }
                };
                
                mediaRecorder.start(100); // Collect data every 100ms
                
                // FIXED: Improved speech detection
                startImprovedSpeechDetection();
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error accessing microphone: ' + error.message);
            }
        }

        function setupAudioVisualization(stream) {
            if (!voiceVisualization) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                // Better settings for voice detection
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.3; // Less smoothing for more responsive detection
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;
                
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                drawVisualization();
            } catch (error) {
                console.error('Audio visualization setup error:', error);
            }
        }

        function drawVisualization() {
            if (!analyser || !voiceVisualization || !isRecording) return;
            
            requestAnimationFrame(drawVisualization);
            
            analyser.getByteFrequencyData(dataArray);
            
            const { canvas, ctx } = voiceVisualization;
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            const barWidth = (width / dataArray.length) * 2.5;
            let x = 0;
            
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * height * 0.8;
                
                const r = Math.floor((dataArray[i] / 255) * 33);
                const g = Math.floor((dataArray[i] / 255) * 150);
                const b = Math.floor((dataArray[i] / 255) * 243);
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }

        // FIXED: Completely rewritten speech detection with better audio analysis
        function startImprovedSpeechDetection() {
            const sensitivity = document.getElementById('speechSensitivity').value;
            const autoStopDelay = parseInt(document.getElementById('autoStopDelay').value);
            const thresholds = speechThresholds[sensitivity];
            
            speechDetectionActive = true;
            speechStartTime = null;
            lastSpeechTime = null;
            speechVolumes = [];
            speechState = 'waiting';
            
            let speechFrameCount = 0;
            let silenceFrameCount = 0;
            let backgroundNoise = 0;
            let noiseCalibrated = false;
            const noiseCalibrationFrames = 30; // Calibrate background noise level
            
            function analyzeAudioLevel() {
                if (!analyser || !isRecording || !speechDetectionActive) {
                    return;
                }
                
                analyser.getByteTimeDomainData(dataArray);
                
                // Calculate actual audio level using time domain data (better for voice)
                let sum = 0;
                let maxAmplitude = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    const sample = (dataArray[i] - 128) / 128; // Normalize to -1 to 1
                    sum += sample * sample;
                    maxAmplitude = Math.max(maxAmplitude, Math.abs(sample));
                }
                
                const rmsLevel = Math.sqrt(sum / dataArray.length) * 100;
                const peakLevel = maxAmplitude * 100;
                
                // Calibrate background noise for first few frames
                if (!noiseCalibrated) {
                    speechVolumes.push(rmsLevel);
                    if (speechVolumes.length >= noiseCalibrationFrames) {
                        backgroundNoise = speechVolumes.reduce((a, b) => a + b, 0) / speechVolumes.length;
                        noiseCalibrated = true;
                        speechVolumes = []; // Reset for actual detection
                        console.log(`Background noise calibrated: ${backgroundNoise.toFixed(2)}`);
                    }
                    if (speechDetectionActive && isRecording) {
                        speechTimer = requestAnimationFrame(analyzeAudioLevel);
                    }
                    return;
                }
                
                // Keep recent volume history for smoothing
                speechVolumes.push(rmsLevel);
                if (speechVolumes.length > 10) {
                    speechVolumes.shift();
                }
                
                const avgRecentVolume = speechVolumes.reduce((a, b) => a + b, 0) / speechVolumes.length;
                const currentTime = Date.now();
                
                // Update volume meter with current level
                const volumeLevel = document.getElementById('volumeLevel');
                const volumePercent = Math.min((rmsLevel / 30) * 100, 100);
                volumeLevel.style.width = `${volumePercent}%`;
                
                // Dynamic threshold based on background noise
                const dynamicThreshold = Math.max(thresholds.volumeThreshold, backgroundNoise * 2.5);
                
                // Voice detection logic - use both RMS and peak, require sustained levels
                const isSpeaking = (rmsLevel > dynamicThreshold && avgRecentVolume > dynamicThreshold * 0.8) ||
                                 (peakLevel > dynamicThreshold * 1.5);
                
                if (isSpeaking) {
                    speechFrameCount++;
                    silenceFrameCount = 0;
                    
                    // Start speech detection after consistent frames
                    if (speechFrameCount >= thresholds.confidenceFrames) {
                        if (speechState === 'waiting') {
                            speechState = 'speaking';
                            speechStartTime = currentTime;
                            console.log(`Speech started - Level: ${rmsLevel.toFixed(1)}, Threshold: ${dynamicThreshold.toFixed(1)}`);
                        }
                        
                        lastSpeechTime = currentTime;
                        
                        // Show visual feedback
                        const indicator = document.getElementById('speechIndicator');
                        indicator.classList.add('active');
                        document.getElementById('voiceStatus').textContent = 'Speaking detected...';
                        document.getElementById('voiceStatus').classList.add('active');
                    }
                } else {
                    silenceFrameCount++;
                    speechFrameCount = 0;
                    
                    // Hide speech indicator after silence
                    if (silenceFrameCount > 10) {
                        const indicator = document.getElementById('speechIndicator');
                        indicator.classList.remove('active');
                    }
                    
                    // Auto-stop logic with improved conditions
                    if (speechState === 'speaking' && lastSpeechTime) {
                        const speechDuration = lastSpeechTime - speechStartTime;
                        const silenceDuration = currentTime - lastSpeechTime;
                        
                        // Enhanced stopping conditions
                        const minSpeechMet = speechDuration >= thresholds.minSpeech;
                        const silenceMet = silenceDuration >= autoStopDelay;
                        const silenceFramesMet = silenceFrameCount >= thresholds.silenceFrames;
                        
                        if (minSpeechMet && silenceMet && silenceFramesMet) {
                            console.log(`Auto-stopping - Speech: ${speechDuration}ms, Silence: ${silenceDuration}ms, Frames: ${silenceFrameCount}`);
                            speechState = 'completed';
                            speechDetectionActive = false;
                            
                            document.getElementById('voiceStatus').textContent = 'Processing speech...';
                            document.getElementById('voiceStatus').classList.remove('active');
                            
                            // Stop recording with slight delay
                            setTimeout(() => {
                                if (isRecording) {
                                    toggleRecording();
                                }
                            }, 100);
                            return;
                        }
                    }
                }
                
                // Continue analysis
                if (speechDetectionActive && isRecording) {
                    speechTimer = requestAnimationFrame(analyzeAudioLevel);
                }
            }
            
            // Start the improved analysis
            console.log('Starting improved speech detection with calibration...');
            analyzeAudioLevel();
        }

        async function stopRecording() {
            speechDetectionActive = false;
            speechState = 'waiting';
            
            if (speechTimer) {
                cancelAnimationFrame(speechTimer);
                speechTimer = null;
            }
            
            if (silenceTimer) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
            }
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            document.getElementById('voiceStatus').classList.remove('active');
        }

        async function transcribeAudio(audioBlob) {
            try {
                document.getElementById('voiceStatus').textContent = 'Transcribing...';
                
                const formData = new FormData();
                formData.append('audio', audioBlob, 'audio.webm');
                
                const response = await fetch(`${BACKEND_BASE_URL}/transcribe`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const transcribedText = data.text;
                    
                    if (transcribedText && transcribedText.trim()) {
                        document.getElementById('messageInput').value = transcribedText;
                        wasVoiceInput = true;
                        document.getElementById('voiceStatus').textContent = 'Transcribed! Sending...';
                        
                        // Auto-send after transcription
                        setTimeout(() => {
                            sendMessage();
                            document.getElementById('voiceStatus').textContent = 'Ready';
                        }, 500);
                    } else {
                        document.getElementById('voiceStatus').textContent = 'No speech detected';
                        setTimeout(() => {
                            document.getElementById('voiceStatus').textContent = 'Ready';
                        }, 2000);
                    }
                } else {
                    console.error('Transcription failed:', response.status);
                    document.getElementById('voiceStatus').textContent = 'Transcription failed';
                    setTimeout(() => {
                        document.getElementById('voiceStatus').textContent = 'Ready';
                    }, 2000);
                }
            } catch (error) {
                console.error('Transcription error:', error);
                document.getElementById('voiceStatus').textContent = 'Error occurred';
                setTimeout(() => {
                    document.getElementById('voiceStatus').textContent = 'Ready';
                }, 2000);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Space bar to start/stop recording (only when input is not focused)
            if (e.code === 'Space' && document.activeElement !== document.getElementById('messageInput')) {
                if (document.getElementById('voiceMode').checked) {
                    e.preventDefault();
                    toggleRecording();
                }
            }
            
            // Escape to stop everything
            if (e.code === 'Escape') {
                if (isRecording) {
                    toggleRecording();
                }
                if (isStreaming) {
                    stopGeneration();
                }
                stopAllAudio();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            speechDetectionActive = false;
            if (isRecording) {
                stopRecording();
            }
            stopAllAudio();
            if (streamController) {
                streamController.abort();
            }
            if (audioContext) {
                audioContext.close();
            }
        });

        // Initialize health check
        setInterval(checkHealth, 30000); // Check every 30 seconds
        </script>
</body>
</html>
